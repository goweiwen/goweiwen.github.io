{"version":3,"sources":["node_modules/smoothscroll-polyfill/dist/smoothscroll.js","node_modules/vivus/dist/vivus.js","index.js"],"names":["document","addEventListener","links","querySelector","preventDefault","classList","toggle","navbarLinks","querySelectorAll","forEach","target","el","getAttribute","e","scrollTo","top","offsetTop","behavior","remove","id","elInView","handleLinksHighlighting","i","length","window","pageYOffset","innerHeight","offsetHeight","add","navbar","scrollPosition","handleNavbarVisibility","nodeList","handleAppearAnimation","removeEventListener","outro","contact","Vivus","duration","type"],"mappings":"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","file":"src.bfb9298f.map","sourceRoot":"src","sourcesContent":["/* smoothscroll v0.4.0 - 2018 - Dustan Kasten, Jeremias Menichelli - MIT License */\n(function () {\n  'use strict';\n\n  // polyfill\n  function polyfill() {\n    // aliases\n    var w = window;\n    var d = document;\n\n    // return if scroll behavior is supported and polyfill is not forced\n    if (\n      'scrollBehavior' in d.documentElement.style &&\n      w.__forceSmoothScrollPolyfill__ !== true\n    ) {\n      return;\n    }\n\n    // globals\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    // object gathering original scroll methods\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      elementScroll: Element.prototype.scroll || scrollElement,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    // define timing method\n    var now =\n      w.performance && w.performance.now\n        ? w.performance.now.bind(w.performance)\n        : Date.now;\n\n    /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */\n    function isMicrosoftBrowser(userAgent) {\n      var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n      return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n    }\n\n    /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */\n    var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */\n    function shouldBailOut(firstArg) {\n      if (\n        firstArg === null ||\n        typeof firstArg !== 'object' ||\n        firstArg.behavior === undefined ||\n        firstArg.behavior === 'auto' ||\n        firstArg.behavior === 'instant'\n      ) {\n        // first argument is not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError(\n        'behavior member of ScrollOptions ' +\n          firstArg.behavior +\n          ' is not a valid value for enumeration ScrollBehavior.'\n      );\n    }\n\n    /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function hasScrollableSpace(el, axis) {\n      if (axis === 'Y') {\n        return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n      }\n\n      if (axis === 'X') {\n        return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n      }\n    }\n\n    /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function canOverflow(el, axis) {\n      var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n      return overflowValue === 'auto' || overflowValue === 'scroll';\n    }\n\n    /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function isScrollable(el) {\n      var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n      var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n      return isScrollableY || isScrollableX;\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      var isBody;\n\n      do {\n        el = el.parentNode;\n\n        isBody = el === d.body;\n      } while (isBody === false && isScrollable(el) === false);\n\n      isBody = null;\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */\n    function step(context) {\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // scroll more if we have not reached our destination\n      if (currentX !== context.x || currentY !== context.y) {\n        w.requestAnimationFrame(step.bind(w, context));\n      }\n    }\n\n    /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y\n      });\n    }\n\n    // ORIGINAL METHODS OVERRIDES\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scroll.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object'\n              ? arguments[0]\n              : w.scrollX || w.pageXOffset,\n          // use top prop, second argument if present or fallback to scrollY\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined\n              ? arguments[1]\n              : w.scrollY || w.pageYOffset\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : w.scrollX || w.pageXOffset,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : w.scrollY || w.pageYOffset\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object' ? arguments[0] : 0,\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined ? arguments[1] : 0\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scroll and Element.prototype.scrollTo\n    Element.prototype.scroll = Element.prototype.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        // if one number is passed, throw error to match Firefox implementation\n        if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n          throw new SyntaxError('Value could not be converted');\n        }\n\n        original.elementScroll.call(\n          this,\n          // use left prop, first number argument or fallback to scrollLeft\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left\n            : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft,\n          // use top prop, second argument or fallback to scrollTop\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top\n            : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop\n        );\n\n        return;\n      }\n\n      var left = arguments[0].left;\n      var top = arguments[0].top;\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        this,\n        this,\n        typeof left === 'undefined' ? this.scrollLeft : ~~left,\n        typeof top === 'undefined' ? this.scrollTop : ~~top\n      );\n    };\n\n    // Element.prototype.scrollBy\n    Element.prototype.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.elementScroll.call(\n          this,\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left + this.scrollLeft\n            : ~~arguments[0] + this.scrollLeft,\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top + this.scrollTop\n            : ~~arguments[1] + this.scrollTop\n        );\n\n        return;\n      }\n\n      this.scroll({\n        left: ~~arguments[0].left + this.scrollLeft,\n        top: ~~arguments[0].top + this.scrollTop,\n        behavior: arguments[0].behavior\n      });\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scrollIntoView.call(\n          this,\n          arguments[0] === undefined ? true : arguments[0]\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n\n        // reveal parent in viewport unless is fixed\n        if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n          w.scrollBy({\n            left: parentRects.left,\n            top: parentRects.top,\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {\n    // global\n    polyfill();\n  }\n\n}());\n","/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.4.2\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n\n'use strict';\n\n(function () {\n\n  'use strict';\n\n/**\n * Pathformer\n * Beta version\n *\n * Take any SVG version 1.1 and transform\n * child elements to 'path' elements\n *\n * This code is purely forked from\n * https://github.com/Waest/SVGPathConverter\n */\n\n/**\n * Class constructor\n *\n * @param {DOM|String} element Dom element of the SVG or id of it\n */\nfunction Pathformer(element) {\n  // Test params\n  if (typeof element === 'undefined') {\n    throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  if (element instanceof window.SVGElement || \n      element instanceof window.SVGGElement ||\n      /^svg$/i.test(element.nodeName)) {\n    this.el = element;\n  } else {\n    throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n  }\n\n  // Start\n  this.scan(element);\n}\n\n/**\n * List of tags which can be transformed\n * to path elements\n *\n * @type {Array}\n */\nPathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n\n/**\n * List of attribute names which contain\n * data. This array list them to check if\n * they contain bad values, like percentage.\n *\n * @type {Array}\n */\nPathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n\n/**\n * Finds the elements compatible for transform\n * and apply the liked method\n *\n * @param  {object} options Object from the constructor\n */\nPathformer.prototype.scan = function (svg) {\n  var fn, element, pathData, pathDom,\n      elements = svg.querySelectorAll(this.TYPES.join(','));\n\n  for (var i = 0; i < elements.length; i++) {\n    element = elements[i];\n    fn = this[element.tagName.toLowerCase() + 'ToPath'];\n    pathData = fn(this.parseAttr(element.attributes));\n    pathDom = this.pathMaker(element, pathData);\n    element.parentNode.replaceChild(pathDom, element);\n  }\n};\n\n\n/**\n * Read `line` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Line element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.lineToPath = function (element) {\n  var newElement = {},\n      x1 = element.x1 || 0,\n      y1 = element.y1 || 0,\n      x2 = element.x2 || 0,\n      y2 = element.y2 || 0;\n\n  newElement.d = 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;\n  return newElement;\n};\n\n/**\n * Read `rect` element to extract and transform\n * data, to make it ready for a `path` object.\n * The radius-border is not taken in charge yet.\n * (your help is more than welcomed)\n *\n * @param  {DOMelement} element Rect element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.rectToPath = function (element) {\n  var newElement = {},\n      x      = parseFloat(element.x)      || 0,\n      y      = parseFloat(element.y)      || 0,\n      width  = parseFloat(element.width)  || 0,\n      height = parseFloat(element.height) || 0;\n\n  if (element.rx || element.ry) {\n    var rx = parseInt(element.rx, 10) || -1,\n        ry = parseInt(element.ry, 10) || -1;\n    rx = Math.min(Math.max(rx < 0 ? ry : rx, 0), width/2);\n    ry = Math.min(Math.max(ry < 0 ? rx : ry, 0), height/2);\n\n    newElement.d = 'M ' + (x + rx) + ',' + y + ' ' +\n                   'L ' + (x + width - rx) + ',' + y + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width) + ',' + (y + ry) + ' ' +\n                   'L ' + (x + width) + ',' + (y + height - ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width - rx) + ',' + (y + height) + ' ' +\n                   'L ' + (x + rx) + ',' + (y + height) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + x + ',' + (y + height - ry) + ' ' +\n                   'L ' + x + ',' + (y + ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + rx) + ',' + y;\n  }\n  else {\n    newElement.d = 'M' + x + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + (y + height) + ' ' +\n                   'L' + x + ' ' + (y + height) + ' Z';\n  }\n  return newElement;\n};\n\n/**\n * Read `polyline` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Polyline element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polylineToPath = function (element) {\n  var newElement = {},\n      points = element.points.trim().split(' '),\n      i, path;\n\n  // Reformatting if points are defined without commas\n  if (element.points.indexOf(',') === -1) {\n    var formattedPoints = [];\n    for (i = 0; i < points.length; i+=2) {\n      formattedPoints.push(points[i] + ',' + points[i+1]);\n    }\n    points = formattedPoints;\n  }\n\n  // Generate the path.d value\n  path = 'M' + points[0];\n  for(i = 1; i < points.length; i++) {\n    if (points[i].indexOf(',') !== -1) {\n      path += 'L' + points[i];\n    }\n  }\n  newElement.d = path;\n  return newElement;\n};\n\n/**\n * Read `polygon` element to extract and transform\n * data, to make it ready for a `path` object.\n * This method rely on polylineToPath, because the\n * logic is similar. The path created is just closed,\n * so it needs an 'Z' at the end.\n *\n * @param  {DOMelement} element Polygon element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polygonToPath = function (element) {\n  var newElement = Pathformer.prototype.polylineToPath(element);\n\n  newElement.d += 'Z';\n  return newElement;\n};\n\n/**\n * Read `ellipse` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element ellipse element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.ellipseToPath = function (element) {\n  var newElement = {},\n      rx = parseFloat(element.rx) || 0,\n      ry = parseFloat(element.ry) || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - rx,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(rx),\n      endY = cy;\n\n  newElement.d = 'M' + startX + ',' + startY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + endX + ',' + endY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Read `circle` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Circle element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.circleToPath = function (element) {\n  var newElement = {},\n      r  = parseFloat(element.r)  || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - r,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(r),\n      endY = cy;\n      \n  newElement.d =  'M' + startX + ',' + startY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + endX + ',' + endY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Create `path` elements form original element\n * and prepared objects\n *\n * @param  {DOMelement} element  Original element to transform\n * @param  {object} pathData     Path data (from `toPath` methods)\n * @return {DOMelement}          Path element\n */\nPathformer.prototype.pathMaker = function (element, pathData) {\n  var i, attr, pathTag = document.createElementNS('http://www.w3.org/2000/svg','path');\n  for(i = 0; i < element.attributes.length; i++) {\n    attr = element.attributes[i];\n    if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n      pathTag.setAttribute(attr.name, attr.value);\n    }\n  }\n  for(i in pathData) {\n    pathTag.setAttribute(i, pathData[i]);\n  }\n  return pathTag;\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of attribute => value\n *\n * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n * @return {object}                  Object of attributes\n */\nPathformer.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  for (var i = 0; i < element.length; i++) {\n    attr = element[i];\n    // Check if no data attribute contains '%', or the transformation is impossible\n    if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n      throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n    }\n    output[attr.name] = attr.value;\n  }\n  return output;\n};\n\n  'use strict';\n\nvar setupEnv, requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n\n/**\n * Vivus\n * Beta version\n *\n * Take any SVG and make the animation\n * to give give the impression of live drawing\n *\n * This in more than just inspired from codrops\n * At that point, it's a pure fork.\n */\n\n/**\n * Class constructor\n * option structure\n *   type: 'delayed'|'sync'|'oneByOne'|'script' (to know if the items must be drawn synchronously or not, default: delayed)\n *   duration: <int> (in frames)\n *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n *   delay: <int> (delay between the drawing of first and last path)\n *   dashGap <integer> whitespace extra margin between dashes\n *   pathTimingFunction <function> timing animation function for each path element of the SVG\n *   animTimingFunction <function> timing animation function for the complete SVG\n *   forceRender <boolean> force the browser to re-render all updated path items\n *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n *\n * The attribute 'type' is by default on 'delayed'.\n *  - 'delayed'\n *    all paths are draw at the same time but with a\n *    little delay between them before start\n *  - 'sync'\n *    all path are start and finish at the same time\n *  - 'oneByOne'\n *    only one path is draw at the time\n *    the end of the first one will trigger the draw\n *    of the next one\n *\n * All these values can be overwritten individually\n * for each path item in the SVG\n * The value of frames will always take the advantage of\n * the duration value.\n * If you fail somewhere, an error will be thrown.\n * Good luck.\n *\n * @constructor\n * @this {Vivus}\n * @param {DOM|String}   element  Dom element of the SVG or id of it\n * @param {Object}       options  Options about the animation\n * @param {Function}     callback Callback for the end of the animation\n */\nfunction Vivus (element, options, callback) {\n\n  setupEnv();\n\n  // Setup\n  this.isReady = false;\n  this.setElement(element, options);\n  this.setOptions(options);\n  this.setCallback(callback);\n\n  if (this.isReady) {\n    this.init();\n  }\n}\n\n/**\n * Timing functions\n **************************************\n *\n * Default functions to help developers.\n * It always take a number as parameter (between 0 to 1) then\n * return a number (between 0 and 1)\n */\nVivus.LINEAR          = function (x) {return x;};\nVivus.EASE            = function (x) {return -Math.cos(x * Math.PI) / 2 + 0.5;};\nVivus.EASE_OUT        = function (x) {return 1 - Math.pow(1-x, 3);};\nVivus.EASE_IN         = function (x) {return Math.pow(x, 3);};\nVivus.EASE_OUT_BOUNCE = function (x) {\n  var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n    rate = Math.pow(base,1.5),\n    rateR = Math.pow(1 - x, 2),\n    progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI) )) + 1;\n  return (1- rateR) + (progress * rateR);\n};\n\n\n/**\n * Setters\n **************************************\n */\n\n/**\n * Check and set the element in the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param {DOM|String}   element  SVG Dom element or id of it\n */\nVivus.prototype.setElement = function (element, options) {\n  // Basic check\n  if (typeof element === 'undefined') {\n    throw new Error('Vivus [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Vivus [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  this.parentEl = element;\n\n  // Create the object element if the property `file` exists in the options object\n  if (options && options.file) {\n    var objElm = document.createElement('object');\n    objElm.setAttribute('type', 'image/svg+xml');\n    objElm.setAttribute('data', options.file);\n    objElm.setAttribute('built-by-vivus', 'true');\n    element.appendChild(objElm);\n    element = objElm;\n  }\n\n  switch (element.constructor) {\n  case window.SVGSVGElement:\n  case window.SVGElement:\n  case window.SVGGElement:\n    this.el = element;\n    this.isReady = true;\n    break;\n\n  case window.HTMLObjectElement:\n    // If we have to wait for it\n    var onLoad, self;\n\n    self = this;\n    onLoad = function (e) {\n      if (self.isReady) {\n        return;\n      }\n      self.el = element.contentDocument && element.contentDocument.querySelector('svg');\n      if (!self.el && e) {\n        throw new Error('Vivus [constructor]: object loaded does not contain any SVG');\n      }\n      else if (self.el) {\n        if (element.getAttribute('built-by-vivus')) {\n          self.parentEl.insertBefore(self.el, element);\n          self.parentEl.removeChild(element);\n          self.el.setAttribute('width', '100%');\n          self.el.setAttribute('height', '100%');\n        }\n        self.isReady = true;\n        self.init();\n        return true;\n      }\n    };\n\n    if (!onLoad()) {\n      element.addEventListener('load', onLoad);\n    }\n    break;\n\n  default:\n    throw new Error('Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)');\n  }\n};\n\n/**\n * Set up user option to the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {object} options Object from the constructor\n */\nVivus.prototype.setOptions = function (options) {\n  var allowedTypes = ['delayed', 'sync', 'async', 'nsync', 'oneByOne', 'scenario', 'scenario-sync'];\n  var allowedStarts =  ['inViewport', 'manual', 'autostart'];\n\n  // Basic check\n  if (options !== undefined && options.constructor !== Object) {\n    throw new Error('Vivus [constructor]: \"options\" parameter must be an object');\n  }\n  else {\n    options = options || {};\n  }\n\n  // Set the animation type\n  if (options.type && allowedTypes.indexOf(options.type) === -1) {\n    throw new Error('Vivus [constructor]: ' + options.type + ' is not an existing animation `type`');\n  }\n  else {\n    this.type = options.type || allowedTypes[0];\n  }\n\n  // Set the start type\n  if (options.start && allowedStarts.indexOf(options.start) === -1) {\n    throw new Error('Vivus [constructor]: ' + options.start + ' is not an existing `start` option');\n  }\n  else {\n    this.start = options.start || allowedStarts[0];\n  }\n\n  this.isIE         = (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.userAgent.indexOf('Trident/') !== -1 || window.navigator.userAgent.indexOf('Edge/') !== -1 );\n  this.duration     = parsePositiveInt(options.duration, 120);\n  this.delay        = parsePositiveInt(options.delay, null);\n  this.dashGap      = parsePositiveInt(options.dashGap, 1);\n  this.forceRender  = options.hasOwnProperty('forceRender') ? !!options.forceRender : this.isIE;\n  this.reverseStack = !!options.reverseStack;\n  this.selfDestroy  = !!options.selfDestroy;\n  this.onReady      = options.onReady;\n  this.map          = [];\n  this.frameLength  = this.currentFrame = this.delayUnit = this.speed = this.handle = null;\n\n  this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible') ? !!options.ignoreInvisible : false;\n\n  this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n  this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n\n  if (this.delay >= this.duration) {\n    throw new Error('Vivus [constructor]: delay must be shorter than duration');\n  }\n};\n\n/**\n * Set up callback to the instance\n * The method will not return enything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {Function} callback Callback for the animation end\n */\nVivus.prototype.setCallback = function (callback) {\n  // Basic check\n  if (!!callback && callback.constructor !== Function) {\n    throw new Error('Vivus [constructor]: \"callback\" parameter must be a function');\n  }\n  this.callback = callback || function () {};\n};\n\n\n/**\n * Core\n **************************************\n */\n\n/**\n * Map the svg, path by path.\n * The method return nothing, it just fill the\n * `map` array. Each item in this array represent\n * a path element from the SVG, with informations for\n * the animation.\n *\n * ```\n * [\n *   {\n *     el: <DOMobj> the path element\n *     length: <number> length of the path line\n *     startAt: <number> time start of the path animation (in frames)\n *     duration: <number> path animation duration (in frames)\n *   },\n *   ...\n * ]\n * ```\n *\n */\nVivus.prototype.mapping = function () {\n  var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint;\n  timePoint = totalLength = lengthMeter = 0;\n  paths = this.el.querySelectorAll('path');\n\n  for (i = 0; i < paths.length; i++) {\n    path = paths[i];\n    if (this.isInvisible(path)) {\n      continue;\n    }\n    pathObj = {\n      el: path,\n      length: Math.ceil(path.getTotalLength())\n    };\n    // Test if the path length is correct\n    if (isNaN(pathObj.length)) {\n      if (window.console && console.warn) {\n        console.warn('Vivus [mapping]: cannot retrieve a path element length', path);\n      }\n      continue;\n    }\n    this.map.push(pathObj);\n    path.style.strokeDasharray  = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    path.style.strokeDashoffset = pathObj.length + this.dashGap;\n    pathObj.length += this.dashGap;\n    totalLength += pathObj.length;\n\n    this.renderPath(i);\n  }\n\n  totalLength = totalLength === 0 ? 1 : totalLength;\n  this.delay = this.delay === null ? this.duration / 3 : this.delay;\n  this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1);\n\n  // Reverse stack if asked\n  if (this.reverseStack) {\n    this.map.reverse();\n  }\n\n  for (i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n\n    switch (this.type) {\n    case 'delayed':\n      pathObj.startAt = this.delayUnit * i;\n      pathObj.duration = this.duration - this.delay;\n      break;\n\n    case 'oneByOne':\n      pathObj.startAt = lengthMeter / totalLength * this.duration;\n      pathObj.duration = pathObj.length / totalLength * this.duration;\n      break;\n\n    case 'sync':\n    case 'async':\n    case 'nsync':\n      pathObj.startAt = 0;\n      pathObj.duration = this.duration;\n      break;\n\n    case 'scenario-sync':\n      path = pathObj.el;\n      pAttrs = this.parseAttr(path);\n      pathObj.startAt = timePoint + (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n      pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n      timePoint = pAttrs['data-async'] !== undefined ? pathObj.startAt : pathObj.startAt + pathObj.duration;\n      this.frameLength = Math.max(this.frameLength, (pathObj.startAt + pathObj.duration));\n      break;\n\n    case 'scenario':\n      path = pathObj.el;\n      pAttrs = this.parseAttr(path);\n      pathObj.startAt = parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n      pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n      this.frameLength = Math.max(this.frameLength, (pathObj.startAt + pathObj.duration));\n      break;\n    }\n    lengthMeter += pathObj.length;\n    this.frameLength = this.frameLength || this.duration;\n  }\n};\n\n/**\n * Interval method to draw the SVG from current\n * position of the animation. It update the value of\n * `currentFrame` and re-trace the SVG.\n *\n * It use this.handle to store the requestAnimationFrame\n * and clear it one the animation is stopped. So this\n * attribute can be used to know if the animation is\n * playing.\n *\n * Once the animation at the end, this method will\n * trigger the Vivus callback.\n *\n */\nVivus.prototype.drawer = function () {\n  var self = this;\n  this.currentFrame += this.speed;\n\n  if (this.currentFrame <= 0) {\n    this.stop();\n    this.reset();\n  } else if (this.currentFrame >= this.frameLength) {\n    this.stop();\n    this.currentFrame = this.frameLength;\n    this.trace();\n    if (this.selfDestroy) {\n      this.destroy();\n    }\n  } else {\n    this.trace();\n    this.handle = requestAnimFrame(function () {\n      self.drawer();\n    });\n    return;\n  }\n\n  this.callback(this);\n  if (this.instanceCallback) {\n    this.instanceCallback(this);\n    this.instanceCallback = null;\n  }\n};\n\n/**\n * Draw the SVG at the current instant from the\n * `currentFrame` value. Here is where most of the magic is.\n * The trick is to use the `strokeDashoffset` style property.\n *\n * For optimisation reasons, a new property called `progress`\n * is added in each item of `map`. This one contain the current\n * progress of the path element. Only if the new value is different\n * the new value will be applied to the DOM element. This\n * method save a lot of resources to re-render the SVG. And could\n * be improved if the animation couldn't be played forward.\n *\n */\nVivus.prototype.trace = function () {\n  var i, progress, path, currentFrame;\n  currentFrame = this.animTimingFunction(this.currentFrame / this.frameLength) * this.frameLength;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    progress = (currentFrame - path.startAt) / path.duration;\n    progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n    if (path.progress !== progress) {\n      path.progress = progress;\n      path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n      this.renderPath(i);\n    }\n  }\n};\n\n/**\n * Method forcing the browser to re-render a path element\n * from it's index in the map. Depending on the `forceRender`\n * value.\n * The trick is to replace the path element by it's clone.\n * This practice is not recommended because it's asking more\n * ressources, too much DOM manupulation..\n * but it's the only way to let the magic happen on IE.\n * By default, this fallback is only applied on IE.\n *\n * @param  {Number} index Path index\n */\nVivus.prototype.renderPath = function (index) {\n  if (this.forceRender && this.map && this.map[index]) {\n    var pathObj = this.map[index],\n        newPath = pathObj.el.cloneNode(true);\n    pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n    pathObj.el = newPath;\n  }\n};\n\n/**\n * When the SVG object is loaded and ready,\n * this method will continue the initialisation.\n *\n * This this mainly due to the case of passing an\n * object tag in the constructor. It will wait\n * the end of the loading to initialise.\n *\n */\nVivus.prototype.init = function () {\n  // Set object variables\n  this.frameLength = 0;\n  this.currentFrame = 0;\n  this.map = [];\n\n  // Start\n  new Pathformer(this.el);\n  this.mapping();\n  this.starter();\n\n  if (this.onReady) {\n    this.onReady(this);\n  }\n};\n\n/**\n * Trigger to start of the animation.\n * Depending on the `start` value, a different script\n * will be applied.\n *\n * If the `start` value is not valid, an error will be thrown.\n * Even if technically, this is impossible.\n *\n */\nVivus.prototype.starter = function () {\n  switch (this.start) {\n  case 'manual':\n    return;\n\n  case 'autostart':\n    this.play();\n    break;\n\n  case 'inViewport':\n    var self = this,\n    listener = function () {\n      if (self.isInViewport(self.parentEl, 1)) {\n        self.play();\n        window.removeEventListener('scroll', listener);\n      }\n    };\n    window.addEventListener('scroll', listener);\n    listener();\n    break;\n  }\n};\n\n\n/**\n * Controls\n **************************************\n */\n\n/**\n * Get the current status of the animation between\n * three different states: 'start', 'progress', 'end'.\n * @return {string} Instance status\n */\nVivus.prototype.getStatus = function () {\n  return this.currentFrame === 0 ? 'start' : this.currentFrame === this.frameLength ? 'end' : 'progress';\n};\n\n/**\n * Reset the instance to the initial state : undraw\n * Be careful, it just reset the animation, if you're\n * playing the animation, this won't stop it. But just\n * make it start from start.\n *\n */\nVivus.prototype.reset = function () {\n  return this.setFrameProgress(0);\n};\n\n/**\n * Set the instance to the final state : drawn\n * Be careful, it just set the animation, if you're\n * playing the animation on rewind, this won't stop it.\n * But just make it start from the end.\n *\n */\nVivus.prototype.finish = function () {\n  return this.setFrameProgress(1);\n};\n\n/**\n * Set the level of progress of the drawing.\n *\n * @param {number} progress Level of progress to set\n */\nVivus.prototype.setFrameProgress = function (progress) {\n  progress = Math.min(1, Math.max(0, progress));\n  this.currentFrame = Math.round(this.frameLength * progress);\n  this.trace();\n  return this;\n};\n\n/**\n * Play the animation at the desired speed.\n * Speed must be a valid number (no zero).\n * By default, the speed value is 1.\n * But a negative value is accepted to go forward.\n *\n * And works with float too.\n * But don't forget we are in JavaScript, se be nice\n * with him and give him a 1/2^x value.\n *\n * @param  {number} speed Animation speed [optional]\n */\nVivus.prototype.play = function (speed, callback) {\n  this.instanceCallback = null;\n\n  if (speed && typeof speed === 'function') {\n    this.instanceCallback = speed; // first parameter is actually the callback function\n    speed = null;\n  }\n  else if (speed && typeof speed !== 'number') {\n    throw new Error('Vivus [play]: invalid speed');\n  }\n  // if the first parameter wasn't the callback, check if the seconds was\n  if (callback && typeof(callback) === 'function' && !this.instanceCallback) {\n    this.instanceCallback = callback;\n  }\n\n\n  this.speed = speed || 1;\n  if (!this.handle) {\n    this.drawer();\n  }\n  return this;\n};\n\n/**\n * Stop the current animation, if on progress.\n * Should not trigger any error.\n *\n */\nVivus.prototype.stop = function () {\n  if (this.handle) {\n    cancelAnimFrame(this.handle);\n    this.handle = null;\n  }\n  return this;\n};\n\n/**\n * Destroy the instance.\n * Remove all bad styling attributes on all\n * path tags\n *\n */\nVivus.prototype.destroy = function () {\n  this.stop();\n  var i, path;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    path.el.style.strokeDashoffset = null;\n    path.el.style.strokeDasharray = null;\n    this.renderPath(i);\n  }\n};\n\n\n/**\n * Utils methods\n * include methods from Codrops\n **************************************\n */\n\n/**\n * Method to best guess if a path should added into\n * the animation or not.\n *\n * 1. Use the `data-vivus-ignore` attribute if set\n * 2. Check if the instance must ignore invisible paths\n * 3. Check if the path is visible\n *\n * For now the visibility checking is unstable.\n * It will be used for a beta phase.\n *\n * Other improvments are planned. Like detecting\n * is the path got a stroke or a valid opacity.\n */\nVivus.prototype.isInvisible = function (el) {\n  var rect,\n    ignoreAttr = el.getAttribute('data-ignore');\n\n  if (ignoreAttr !== null) {\n    return ignoreAttr !== 'false';\n  }\n\n  if (this.ignoreInvisible) {\n    rect = el.getBoundingClientRect();\n    return !rect.width && !rect.height;\n  }\n  else {\n    return false;\n  }\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of {attributeName => attributeValue}\n *\n * @param  {object} element DOM element to parse\n * @return {object}         Object of attributes\n */\nVivus.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  if (element && element.attributes) {\n    for (var i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n      output[attr.name] = attr.value;\n    }\n  }\n  return output;\n};\n\n/**\n * Reply if an element is in the page viewport\n *\n * @param  {object} el Element to observe\n * @param  {number} h  Percentage of height\n * @return {boolean}\n */\nVivus.prototype.isInViewport = function (el, h) {\n  var scrolled   = this.scrollY(),\n    viewed       = scrolled + this.getViewportH(),\n    elBCR        = el.getBoundingClientRect(),\n    elHeight     = elBCR.height,\n    elTop        = scrolled + elBCR.top,\n    elBottom     = elTop + elHeight;\n\n  // if 0, the element is considered in the viewport as soon as it enters.\n  // if 1, the element is considered in the viewport only when it's fully inside\n  // value in percentage (1 >= h >= 0)\n  h = h || 0;\n\n  return (elTop + elHeight * h) <= viewed && (elBottom) >= scrolled;\n};\n\n\n/**\n * Get the viewport height in pixels\n *\n * @return {integer} Viewport height\n */\nVivus.prototype.getViewportH = function () {\n  var client = this.docElem.clientHeight,\n    inner = window.innerHeight;\n\n  if (client < inner) {\n    return inner;\n  }\n  else {\n    return client;\n  }\n};\n\n/**\n * Get the page Y offset\n *\n * @return {integer} Page Y offset\n */\nVivus.prototype.scrollY = function () {\n  return window.pageYOffset || this.docElem.scrollTop;\n};\n\nsetupEnv = function () {\n\n  if (Vivus.prototype.docElem) {\n    return;\n  }\n\n  /**\n   * Alias for document element\n   *\n   * @type {DOMelement}\n   */\n  Vivus.prototype.docElem = window.document.documentElement;\n\n  /**\n   * Alias for `requestAnimationFrame` or\n   * `setTimeout` function for deprecated browsers.\n   *\n   */\n  requestAnimFrame = (function () {\n    return (\n      window.requestAnimationFrame       ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame    ||\n      window.oRequestAnimationFrame      ||\n      window.msRequestAnimationFrame     ||\n      function(/* function */ callback){\n        return window.setTimeout(callback, 1000 / 60);\n      }\n    );\n  })();\n\n  /**\n   * Alias for `cancelAnimationFrame` or\n   * `cancelTimeout` function for deprecated browsers.\n   *\n   */\n  cancelAnimFrame = (function () {\n    return (\n      window.cancelAnimationFrame       ||\n      window.webkitCancelAnimationFrame ||\n      window.mozCancelAnimationFrame    ||\n      window.oCancelAnimationFrame      ||\n      window.msCancelAnimationFrame     ||\n      function(id){\n        return window.clearTimeout(id);\n      }\n    );\n  })();\n};\n\n/**\n * Parse string to integer.\n * If the number is not positive or null\n * the method will return the default value\n * or 0 if undefined\n *\n * @param {string} value String to parse\n * @param {*} defaultValue Value to return if the result parsed is invalid\n * @return {number}\n *\n */\nparsePositiveInt = function (value, defaultValue) {\n  var output = parseInt(value, 10);\n  return (output >= 0) ? output : defaultValue;\n};\n\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function() {\n      return Vivus;\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Vivus;\n  } else {\n    // Browser globals\n    window.Vivus = Vivus;\n  }\n\n}());\n","import { polyfill } from 'smoothscroll-polyfill';\nimport Vivus from 'vivus';\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  // Hamburger\n  const links = document.querySelector('.links');\n  document.querySelector('.hamburger').addEventListener('click', e => {\n    e.preventDefault();\n    links.classList.toggle('is-visible');\n    ga('send', 'event', 'cv', 'hamburger');\n  });\n\n  // Links\n  polyfill();\n  const navbarLinks = document.querySelectorAll('.navbar .link');\n  navbarLinks.forEach(el => {\n    const target = document.querySelector(el.getAttribute('href'));\n    el.addEventListener('click', function(e) {\n      e.preventDefault();\n      window.scrollTo({ top: target.offsetTop - 96, behavior: 'smooth' });\n      links.classList.remove('is-visible');\n      ga('send', 'event', 'cv', 'navigate', target.id);\n    });\n  });\n\n  let elInView;\n  function handleLinksHighlighting() {\n    for (let i = 0; i < navbarLinks.length; i++) {\n      const el = navbarLinks[i];\n      const target = document.querySelector(el.getAttribute('href'));\n      if (\n        target.offsetTop - 96 <= window.pageYOffset + window.innerHeight &&\n        target.offsetTop - 96 + target.offsetHeight > window.pageYOffset\n      ) {\n        if (el !== elInView) {\n          el.classList.add('is-active');\n          elInView && elInView.classList.remove('is-active');\n          elInView = el;\n          ga('send', 'event', 'cv', 'scroll', target.id);\n        }\n        return;\n      }\n    }\n  }\n  window.addEventListener('scroll', handleLinksHighlighting);\n\n  // Navbar visibility\n  const navbar = document.querySelector('.navbar');\n  let scrollPosition = window.pageYOffset;\n  function handleNavbarVisibility() {\n    if (window.pageYOffset < 32) {\n      navbar.classList.add('is-transparent');\n    } else {\n      navbar.classList.remove('is-transparent');\n    }\n    if (scrollPosition >= window.pageYOffset) {\n      navbar.classList.remove('is-hidden');\n    } else {\n      navbar.classList.add('is-hidden');\n      links.classList.remove('is-visible');\n    }\n    scrollPosition = window.pageYOffset;\n  }\n  window.addEventListener('scroll', handleNavbarVisibility);\n  handleNavbarVisibility();\n\n  // Scroll Animation\n  document.querySelectorAll('main > *').forEach(el => {\n    el.classList.add('is-hidden');\n  });\n  let nodeList = document.querySelectorAll('main > .is-hidden');\n  function handleAppearAnimation() {\n    nodeList.forEach(el => {\n      if (\n        el.offsetTop <= window.pageYOffset + window.innerHeight &&\n        el.offsetTop + el.offsetHeight > window.pageYOffset\n      ) {\n        nodeList = document.querySelectorAll('main > .is-hidden');\n        el.classList.remove('is-hidden');\n      }\n    });\n    if (nodeList.length === 0) {\n      window.removeEventListener('scroll', handleAppearAnimation);\n    }\n  }\n  window.addEventListener('scroll', handleAppearAnimation);\n  handleAppearAnimation();\n\n  // SVG Animation\n  const outro = document.querySelector('.hero .outro');\n  const contact = document.querySelector('.hero .contact');\n  outro.classList.add('is-hidden');\n  contact.classList.add('is-hidden');\n  new Vivus('logo', { duration: 200, type: 'oneByOne' }, () => {\n    outro.classList.remove('is-hidden');\n    contact.classList.remove('is-hidden');\n  });\n});\n"]}